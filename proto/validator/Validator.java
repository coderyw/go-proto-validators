// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: validator.proto
// Protobuf Java Version: 4.27.2

package validator;

public final class Validator {
  private Validator() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 27,
      /* patch= */ 2,
      /* suffix= */ "",
      Validator.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
    registry.add(validator.Validator.field);
    registry.add(validator.Validator.oneof);
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface FieldValidatorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:validator.FieldValidator)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Uses a Golang RE2-syntax regex to match the field contents.
     * </pre>
     *
     * <code>optional string regex = 1;</code>
     * @return Whether the regex field is set.
     */
    boolean hasRegex();
    /**
     * <pre>
     * Uses a Golang RE2-syntax regex to match the field contents.
     * </pre>
     *
     * <code>optional string regex = 1;</code>
     * @return The regex.
     */
    java.lang.String getRegex();
    /**
     * <pre>
     * Uses a Golang RE2-syntax regex to match the field contents.
     * </pre>
     *
     * <code>optional string regex = 1;</code>
     * @return The bytes for regex.
     */
    com.google.protobuf.ByteString
        getRegexBytes();

    /**
     * <pre>
     * Field value of integer strictly greater than this value.
     * </pre>
     *
     * <code>optional int64 int_gt = 2;</code>
     * @return Whether the intGt field is set.
     */
    boolean hasIntGt();
    /**
     * <pre>
     * Field value of integer strictly greater than this value.
     * </pre>
     *
     * <code>optional int64 int_gt = 2;</code>
     * @return The intGt.
     */
    long getIntGt();

    /**
     * <pre>
     * Field value of integer strictly smaller than this value.
     * </pre>
     *
     * <code>optional int64 int_lt = 3;</code>
     * @return Whether the intLt field is set.
     */
    boolean hasIntLt();
    /**
     * <pre>
     * Field value of integer strictly smaller than this value.
     * </pre>
     *
     * <code>optional int64 int_lt = 3;</code>
     * @return The intLt.
     */
    long getIntLt();

    /**
     * <pre>
     * Used for nested message types, requires that the message type exists.
     * </pre>
     *
     * <code>optional bool msg_exists = 4;</code>
     * @return Whether the msgExists field is set.
     */
    boolean hasMsgExists();
    /**
     * <pre>
     * Used for nested message types, requires that the message type exists.
     * </pre>
     *
     * <code>optional bool msg_exists = 4;</code>
     * @return The msgExists.
     */
    boolean getMsgExists();

    /**
     * <pre>
     * 必填参数，参数非零值
     * </pre>
     *
     * <code>optional bool required = 19;</code>
     * @return Whether the required field is set.
     */
    boolean hasRequired();
    /**
     * <pre>
     * 必填参数，参数非零值
     * </pre>
     *
     * <code>optional bool required = 19;</code>
     * @return The required.
     */
    boolean getRequired();

    /**
     * <pre>
     * Human error specifies a user-customizable error that is visible to the user.
     * </pre>
     *
     * <code>optional string human_error = 5;</code>
     * @return Whether the humanError field is set.
     */
    boolean hasHumanError();
    /**
     * <pre>
     * Human error specifies a user-customizable error that is visible to the user.
     * </pre>
     *
     * <code>optional string human_error = 5;</code>
     * @return The humanError.
     */
    java.lang.String getHumanError();
    /**
     * <pre>
     * Human error specifies a user-customizable error that is visible to the user.
     * </pre>
     *
     * <code>optional string human_error = 5;</code>
     * @return The bytes for humanError.
     */
    com.google.protobuf.ByteString
        getHumanErrorBytes();

    /**
     * <pre>
     * Field value of double strictly greater than this value.
     * Note that this value can only take on a valid floating point
     * value. Use together with float_epsilon if you need something more specific.
     * </pre>
     *
     * <code>optional double float_gt = 6;</code>
     * @return Whether the floatGt field is set.
     */
    boolean hasFloatGt();
    /**
     * <pre>
     * Field value of double strictly greater than this value.
     * Note that this value can only take on a valid floating point
     * value. Use together with float_epsilon if you need something more specific.
     * </pre>
     *
     * <code>optional double float_gt = 6;</code>
     * @return The floatGt.
     */
    double getFloatGt();

    /**
     * <pre>
     * Field value of double strictly smaller than this value.
     * Note that this value can only take on a valid floating point
     * value. Use together with float_epsilon if you need something more specific.
     * </pre>
     *
     * <code>optional double float_lt = 7;</code>
     * @return Whether the floatLt field is set.
     */
    boolean hasFloatLt();
    /**
     * <pre>
     * Field value of double strictly smaller than this value.
     * Note that this value can only take on a valid floating point
     * value. Use together with float_epsilon if you need something more specific.
     * </pre>
     *
     * <code>optional double float_lt = 7;</code>
     * @return The floatLt.
     */
    double getFloatLt();

    /**
     * <pre>
     * Field value of double describing the epsilon within which
     * any comparison should be considered to be true. For example,
     * when using float_gt = 0.35, using a float_epsilon of 0.05
     * would mean that any value above 0.30 is acceptable. It can be
     * thought of as a {float_value_condition} +- {float_epsilon}.
     * If unset, no correction for floating point inaccuracies in
     * comparisons will be attempted.
     * </pre>
     *
     * <code>optional double float_epsilon = 8;</code>
     * @return Whether the floatEpsilon field is set.
     */
    boolean hasFloatEpsilon();
    /**
     * <pre>
     * Field value of double describing the epsilon within which
     * any comparison should be considered to be true. For example,
     * when using float_gt = 0.35, using a float_epsilon of 0.05
     * would mean that any value above 0.30 is acceptable. It can be
     * thought of as a {float_value_condition} +- {float_epsilon}.
     * If unset, no correction for floating point inaccuracies in
     * comparisons will be attempted.
     * </pre>
     *
     * <code>optional double float_epsilon = 8;</code>
     * @return The floatEpsilon.
     */
    double getFloatEpsilon();

    /**
     * <pre>
     * Floating-point value compared to which the field content should be greater or equal.
     * </pre>
     *
     * <code>optional double float_gte = 9;</code>
     * @return Whether the floatGte field is set.
     */
    boolean hasFloatGte();
    /**
     * <pre>
     * Floating-point value compared to which the field content should be greater or equal.
     * </pre>
     *
     * <code>optional double float_gte = 9;</code>
     * @return The floatGte.
     */
    double getFloatGte();

    /**
     * <pre>
     * Floating-point value compared to which the field content should be smaller or equal.
     * </pre>
     *
     * <code>optional double float_lte = 10;</code>
     * @return Whether the floatLte field is set.
     */
    boolean hasFloatLte();
    /**
     * <pre>
     * Floating-point value compared to which the field content should be smaller or equal.
     * </pre>
     *
     * <code>optional double float_lte = 10;</code>
     * @return The floatLte.
     */
    double getFloatLte();

    /**
     * <pre>
     * Used for string fields, requires the string to be not empty (i.e different from "").
     * </pre>
     *
     * <code>optional bool string_not_empty = 11;</code>
     * @return Whether the stringNotEmpty field is set.
     */
    boolean hasStringNotEmpty();
    /**
     * <pre>
     * Used for string fields, requires the string to be not empty (i.e different from "").
     * </pre>
     *
     * <code>optional bool string_not_empty = 11;</code>
     * @return The stringNotEmpty.
     */
    boolean getStringNotEmpty();

    /**
     * <pre>
     * Repeated field with at least this number of elements.
     * </pre>
     *
     * <code>optional int64 repeated_count_min = 12;</code>
     * @return Whether the repeatedCountMin field is set.
     */
    boolean hasRepeatedCountMin();
    /**
     * <pre>
     * Repeated field with at least this number of elements.
     * </pre>
     *
     * <code>optional int64 repeated_count_min = 12;</code>
     * @return The repeatedCountMin.
     */
    long getRepeatedCountMin();

    /**
     * <pre>
     * Repeated field with at most this number of elements.
     * </pre>
     *
     * <code>optional int64 repeated_count_max = 13;</code>
     * @return Whether the repeatedCountMax field is set.
     */
    boolean hasRepeatedCountMax();
    /**
     * <pre>
     * Repeated field with at most this number of elements.
     * </pre>
     *
     * <code>optional int64 repeated_count_max = 13;</code>
     * @return The repeatedCountMax.
     */
    long getRepeatedCountMax();

    /**
     * <pre>
     * Field value of length greater than this value.
     * </pre>
     *
     * <code>optional int64 length_gt = 14;</code>
     * @return Whether the lengthGt field is set.
     */
    boolean hasLengthGt();
    /**
     * <pre>
     * Field value of length greater than this value.
     * </pre>
     *
     * <code>optional int64 length_gt = 14;</code>
     * @return The lengthGt.
     */
    long getLengthGt();

    /**
     * <pre>
     * Field value of length smaller than this value.
     * </pre>
     *
     * <code>optional int64 length_lt = 15;</code>
     * @return Whether the lengthLt field is set.
     */
    boolean hasLengthLt();
    /**
     * <pre>
     * Field value of length smaller than this value.
     * </pre>
     *
     * <code>optional int64 length_lt = 15;</code>
     * @return The lengthLt.
     */
    long getLengthLt();

    /**
     * <pre>
     * Field value of length strictly equal to this value.
     * </pre>
     *
     * <code>optional int64 length_eq = 16;</code>
     * @return Whether the lengthEq field is set.
     */
    boolean hasLengthEq();
    /**
     * <pre>
     * Field value of length strictly equal to this value.
     * </pre>
     *
     * <code>optional int64 length_eq = 16;</code>
     * @return The lengthEq.
     */
    long getLengthEq();

    /**
     * <pre>
     * Requires that the value is in the enum.
     * </pre>
     *
     * <code>optional bool is_in_enum = 17;</code>
     * @return Whether the isInEnum field is set.
     */
    boolean hasIsInEnum();
    /**
     * <pre>
     * Requires that the value is in the enum.
     * </pre>
     *
     * <code>optional bool is_in_enum = 17;</code>
     * @return The isInEnum.
     */
    boolean getIsInEnum();

    /**
     * <pre>
     * Ensures that a string value is in UUID format.
     * uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
     * If uuid_ver is 0 all UUID versions are accepted.
     * </pre>
     *
     * <code>optional int32 uuid_ver = 18;</code>
     * @return Whether the uuidVer field is set.
     */
    boolean hasUuidVer();
    /**
     * <pre>
     * Ensures that a string value is in UUID format.
     * uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
     * If uuid_ver is 0 all UUID versions are accepted.
     * </pre>
     *
     * <code>optional int32 uuid_ver = 18;</code>
     * @return The uuidVer.
     */
    int getUuidVer();

    /**
     * <pre>
     * 字符串长度大于，属于字符串文字长度
     * </pre>
     *
     * <code>optional int64 string_length_gt = 20;</code>
     * @return Whether the stringLengthGt field is set.
     */
    boolean hasStringLengthGt();
    /**
     * <pre>
     * 字符串长度大于，属于字符串文字长度
     * </pre>
     *
     * <code>optional int64 string_length_gt = 20;</code>
     * @return The stringLengthGt.
     */
    long getStringLengthGt();

    /**
     * <code>optional int64 string_length_lt = 21;</code>
     * @return Whether the stringLengthLt field is set.
     */
    boolean hasStringLengthLt();
    /**
     * <code>optional int64 string_length_lt = 21;</code>
     * @return The stringLengthLt.
     */
    long getStringLengthLt();

    /**
     * <code>optional int64 string_length_eq = 22;</code>
     * @return Whether the stringLengthEq field is set.
     */
    boolean hasStringLengthEq();
    /**
     * <code>optional int64 string_length_eq = 22;</code>
     * @return The stringLengthEq.
     */
    long getStringLengthEq();
  }
  /**
   * Protobuf type {@code validator.FieldValidator}
   */
  public static final class FieldValidator extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:validator.FieldValidator)
      FieldValidatorOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 27,
        /* patch= */ 2,
        /* suffix= */ "",
        FieldValidator.class.getName());
    }
    // Use FieldValidator.newBuilder() to construct.
    private FieldValidator(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private FieldValidator() {
      regex_ = "";
      humanError_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return validator.Validator.internal_static_validator_FieldValidator_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return validator.Validator.internal_static_validator_FieldValidator_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              validator.Validator.FieldValidator.class, validator.Validator.FieldValidator.Builder.class);
    }

    private int bitField0_;
    public static final int REGEX_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object regex_ = "";
    /**
     * <pre>
     * Uses a Golang RE2-syntax regex to match the field contents.
     * </pre>
     *
     * <code>optional string regex = 1;</code>
     * @return Whether the regex field is set.
     */
    @java.lang.Override
    public boolean hasRegex() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Uses a Golang RE2-syntax regex to match the field contents.
     * </pre>
     *
     * <code>optional string regex = 1;</code>
     * @return The regex.
     */
    @java.lang.Override
    public java.lang.String getRegex() {
      java.lang.Object ref = regex_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          regex_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Uses a Golang RE2-syntax regex to match the field contents.
     * </pre>
     *
     * <code>optional string regex = 1;</code>
     * @return The bytes for regex.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRegexBytes() {
      java.lang.Object ref = regex_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        regex_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INT_GT_FIELD_NUMBER = 2;
    private long intGt_ = 0L;
    /**
     * <pre>
     * Field value of integer strictly greater than this value.
     * </pre>
     *
     * <code>optional int64 int_gt = 2;</code>
     * @return Whether the intGt field is set.
     */
    @java.lang.Override
    public boolean hasIntGt() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Field value of integer strictly greater than this value.
     * </pre>
     *
     * <code>optional int64 int_gt = 2;</code>
     * @return The intGt.
     */
    @java.lang.Override
    public long getIntGt() {
      return intGt_;
    }

    public static final int INT_LT_FIELD_NUMBER = 3;
    private long intLt_ = 0L;
    /**
     * <pre>
     * Field value of integer strictly smaller than this value.
     * </pre>
     *
     * <code>optional int64 int_lt = 3;</code>
     * @return Whether the intLt field is set.
     */
    @java.lang.Override
    public boolean hasIntLt() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Field value of integer strictly smaller than this value.
     * </pre>
     *
     * <code>optional int64 int_lt = 3;</code>
     * @return The intLt.
     */
    @java.lang.Override
    public long getIntLt() {
      return intLt_;
    }

    public static final int MSG_EXISTS_FIELD_NUMBER = 4;
    private boolean msgExists_ = false;
    /**
     * <pre>
     * Used for nested message types, requires that the message type exists.
     * </pre>
     *
     * <code>optional bool msg_exists = 4;</code>
     * @return Whether the msgExists field is set.
     */
    @java.lang.Override
    public boolean hasMsgExists() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Used for nested message types, requires that the message type exists.
     * </pre>
     *
     * <code>optional bool msg_exists = 4;</code>
     * @return The msgExists.
     */
    @java.lang.Override
    public boolean getMsgExists() {
      return msgExists_;
    }

    public static final int REQUIRED_FIELD_NUMBER = 19;
    private boolean required_ = false;
    /**
     * <pre>
     * 必填参数，参数非零值
     * </pre>
     *
     * <code>optional bool required = 19;</code>
     * @return Whether the required field is set.
     */
    @java.lang.Override
    public boolean hasRequired() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * 必填参数，参数非零值
     * </pre>
     *
     * <code>optional bool required = 19;</code>
     * @return The required.
     */
    @java.lang.Override
    public boolean getRequired() {
      return required_;
    }

    public static final int HUMAN_ERROR_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object humanError_ = "";
    /**
     * <pre>
     * Human error specifies a user-customizable error that is visible to the user.
     * </pre>
     *
     * <code>optional string human_error = 5;</code>
     * @return Whether the humanError field is set.
     */
    @java.lang.Override
    public boolean hasHumanError() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Human error specifies a user-customizable error that is visible to the user.
     * </pre>
     *
     * <code>optional string human_error = 5;</code>
     * @return The humanError.
     */
    @java.lang.Override
    public java.lang.String getHumanError() {
      java.lang.Object ref = humanError_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          humanError_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Human error specifies a user-customizable error that is visible to the user.
     * </pre>
     *
     * <code>optional string human_error = 5;</code>
     * @return The bytes for humanError.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHumanErrorBytes() {
      java.lang.Object ref = humanError_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        humanError_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FLOAT_GT_FIELD_NUMBER = 6;
    private double floatGt_ = 0D;
    /**
     * <pre>
     * Field value of double strictly greater than this value.
     * Note that this value can only take on a valid floating point
     * value. Use together with float_epsilon if you need something more specific.
     * </pre>
     *
     * <code>optional double float_gt = 6;</code>
     * @return Whether the floatGt field is set.
     */
    @java.lang.Override
    public boolean hasFloatGt() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Field value of double strictly greater than this value.
     * Note that this value can only take on a valid floating point
     * value. Use together with float_epsilon if you need something more specific.
     * </pre>
     *
     * <code>optional double float_gt = 6;</code>
     * @return The floatGt.
     */
    @java.lang.Override
    public double getFloatGt() {
      return floatGt_;
    }

    public static final int FLOAT_LT_FIELD_NUMBER = 7;
    private double floatLt_ = 0D;
    /**
     * <pre>
     * Field value of double strictly smaller than this value.
     * Note that this value can only take on a valid floating point
     * value. Use together with float_epsilon if you need something more specific.
     * </pre>
     *
     * <code>optional double float_lt = 7;</code>
     * @return Whether the floatLt field is set.
     */
    @java.lang.Override
    public boolean hasFloatLt() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Field value of double strictly smaller than this value.
     * Note that this value can only take on a valid floating point
     * value. Use together with float_epsilon if you need something more specific.
     * </pre>
     *
     * <code>optional double float_lt = 7;</code>
     * @return The floatLt.
     */
    @java.lang.Override
    public double getFloatLt() {
      return floatLt_;
    }

    public static final int FLOAT_EPSILON_FIELD_NUMBER = 8;
    private double floatEpsilon_ = 0D;
    /**
     * <pre>
     * Field value of double describing the epsilon within which
     * any comparison should be considered to be true. For example,
     * when using float_gt = 0.35, using a float_epsilon of 0.05
     * would mean that any value above 0.30 is acceptable. It can be
     * thought of as a {float_value_condition} +- {float_epsilon}.
     * If unset, no correction for floating point inaccuracies in
     * comparisons will be attempted.
     * </pre>
     *
     * <code>optional double float_epsilon = 8;</code>
     * @return Whether the floatEpsilon field is set.
     */
    @java.lang.Override
    public boolean hasFloatEpsilon() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Field value of double describing the epsilon within which
     * any comparison should be considered to be true. For example,
     * when using float_gt = 0.35, using a float_epsilon of 0.05
     * would mean that any value above 0.30 is acceptable. It can be
     * thought of as a {float_value_condition} +- {float_epsilon}.
     * If unset, no correction for floating point inaccuracies in
     * comparisons will be attempted.
     * </pre>
     *
     * <code>optional double float_epsilon = 8;</code>
     * @return The floatEpsilon.
     */
    @java.lang.Override
    public double getFloatEpsilon() {
      return floatEpsilon_;
    }

    public static final int FLOAT_GTE_FIELD_NUMBER = 9;
    private double floatGte_ = 0D;
    /**
     * <pre>
     * Floating-point value compared to which the field content should be greater or equal.
     * </pre>
     *
     * <code>optional double float_gte = 9;</code>
     * @return Whether the floatGte field is set.
     */
    @java.lang.Override
    public boolean hasFloatGte() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Floating-point value compared to which the field content should be greater or equal.
     * </pre>
     *
     * <code>optional double float_gte = 9;</code>
     * @return The floatGte.
     */
    @java.lang.Override
    public double getFloatGte() {
      return floatGte_;
    }

    public static final int FLOAT_LTE_FIELD_NUMBER = 10;
    private double floatLte_ = 0D;
    /**
     * <pre>
     * Floating-point value compared to which the field content should be smaller or equal.
     * </pre>
     *
     * <code>optional double float_lte = 10;</code>
     * @return Whether the floatLte field is set.
     */
    @java.lang.Override
    public boolean hasFloatLte() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Floating-point value compared to which the field content should be smaller or equal.
     * </pre>
     *
     * <code>optional double float_lte = 10;</code>
     * @return The floatLte.
     */
    @java.lang.Override
    public double getFloatLte() {
      return floatLte_;
    }

    public static final int STRING_NOT_EMPTY_FIELD_NUMBER = 11;
    private boolean stringNotEmpty_ = false;
    /**
     * <pre>
     * Used for string fields, requires the string to be not empty (i.e different from "").
     * </pre>
     *
     * <code>optional bool string_not_empty = 11;</code>
     * @return Whether the stringNotEmpty field is set.
     */
    @java.lang.Override
    public boolean hasStringNotEmpty() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Used for string fields, requires the string to be not empty (i.e different from "").
     * </pre>
     *
     * <code>optional bool string_not_empty = 11;</code>
     * @return The stringNotEmpty.
     */
    @java.lang.Override
    public boolean getStringNotEmpty() {
      return stringNotEmpty_;
    }

    public static final int REPEATED_COUNT_MIN_FIELD_NUMBER = 12;
    private long repeatedCountMin_ = 0L;
    /**
     * <pre>
     * Repeated field with at least this number of elements.
     * </pre>
     *
     * <code>optional int64 repeated_count_min = 12;</code>
     * @return Whether the repeatedCountMin field is set.
     */
    @java.lang.Override
    public boolean hasRepeatedCountMin() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Repeated field with at least this number of elements.
     * </pre>
     *
     * <code>optional int64 repeated_count_min = 12;</code>
     * @return The repeatedCountMin.
     */
    @java.lang.Override
    public long getRepeatedCountMin() {
      return repeatedCountMin_;
    }

    public static final int REPEATED_COUNT_MAX_FIELD_NUMBER = 13;
    private long repeatedCountMax_ = 0L;
    /**
     * <pre>
     * Repeated field with at most this number of elements.
     * </pre>
     *
     * <code>optional int64 repeated_count_max = 13;</code>
     * @return Whether the repeatedCountMax field is set.
     */
    @java.lang.Override
    public boolean hasRepeatedCountMax() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Repeated field with at most this number of elements.
     * </pre>
     *
     * <code>optional int64 repeated_count_max = 13;</code>
     * @return The repeatedCountMax.
     */
    @java.lang.Override
    public long getRepeatedCountMax() {
      return repeatedCountMax_;
    }

    public static final int LENGTH_GT_FIELD_NUMBER = 14;
    private long lengthGt_ = 0L;
    /**
     * <pre>
     * Field value of length greater than this value.
     * </pre>
     *
     * <code>optional int64 length_gt = 14;</code>
     * @return Whether the lengthGt field is set.
     */
    @java.lang.Override
    public boolean hasLengthGt() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Field value of length greater than this value.
     * </pre>
     *
     * <code>optional int64 length_gt = 14;</code>
     * @return The lengthGt.
     */
    @java.lang.Override
    public long getLengthGt() {
      return lengthGt_;
    }

    public static final int LENGTH_LT_FIELD_NUMBER = 15;
    private long lengthLt_ = 0L;
    /**
     * <pre>
     * Field value of length smaller than this value.
     * </pre>
     *
     * <code>optional int64 length_lt = 15;</code>
     * @return Whether the lengthLt field is set.
     */
    @java.lang.Override
    public boolean hasLengthLt() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Field value of length smaller than this value.
     * </pre>
     *
     * <code>optional int64 length_lt = 15;</code>
     * @return The lengthLt.
     */
    @java.lang.Override
    public long getLengthLt() {
      return lengthLt_;
    }

    public static final int LENGTH_EQ_FIELD_NUMBER = 16;
    private long lengthEq_ = 0L;
    /**
     * <pre>
     * Field value of length strictly equal to this value.
     * </pre>
     *
     * <code>optional int64 length_eq = 16;</code>
     * @return Whether the lengthEq field is set.
     */
    @java.lang.Override
    public boolean hasLengthEq() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Field value of length strictly equal to this value.
     * </pre>
     *
     * <code>optional int64 length_eq = 16;</code>
     * @return The lengthEq.
     */
    @java.lang.Override
    public long getLengthEq() {
      return lengthEq_;
    }

    public static final int IS_IN_ENUM_FIELD_NUMBER = 17;
    private boolean isInEnum_ = false;
    /**
     * <pre>
     * Requires that the value is in the enum.
     * </pre>
     *
     * <code>optional bool is_in_enum = 17;</code>
     * @return Whether the isInEnum field is set.
     */
    @java.lang.Override
    public boolean hasIsInEnum() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Requires that the value is in the enum.
     * </pre>
     *
     * <code>optional bool is_in_enum = 17;</code>
     * @return The isInEnum.
     */
    @java.lang.Override
    public boolean getIsInEnum() {
      return isInEnum_;
    }

    public static final int UUID_VER_FIELD_NUMBER = 18;
    private int uuidVer_ = 0;
    /**
     * <pre>
     * Ensures that a string value is in UUID format.
     * uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
     * If uuid_ver is 0 all UUID versions are accepted.
     * </pre>
     *
     * <code>optional int32 uuid_ver = 18;</code>
     * @return Whether the uuidVer field is set.
     */
    @java.lang.Override
    public boolean hasUuidVer() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * Ensures that a string value is in UUID format.
     * uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
     * If uuid_ver is 0 all UUID versions are accepted.
     * </pre>
     *
     * <code>optional int32 uuid_ver = 18;</code>
     * @return The uuidVer.
     */
    @java.lang.Override
    public int getUuidVer() {
      return uuidVer_;
    }

    public static final int STRING_LENGTH_GT_FIELD_NUMBER = 20;
    private long stringLengthGt_ = 0L;
    /**
     * <pre>
     * 字符串长度大于，属于字符串文字长度
     * </pre>
     *
     * <code>optional int64 string_length_gt = 20;</code>
     * @return Whether the stringLengthGt field is set.
     */
    @java.lang.Override
    public boolean hasStringLengthGt() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * 字符串长度大于，属于字符串文字长度
     * </pre>
     *
     * <code>optional int64 string_length_gt = 20;</code>
     * @return The stringLengthGt.
     */
    @java.lang.Override
    public long getStringLengthGt() {
      return stringLengthGt_;
    }

    public static final int STRING_LENGTH_LT_FIELD_NUMBER = 21;
    private long stringLengthLt_ = 0L;
    /**
     * <code>optional int64 string_length_lt = 21;</code>
     * @return Whether the stringLengthLt field is set.
     */
    @java.lang.Override
    public boolean hasStringLengthLt() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <code>optional int64 string_length_lt = 21;</code>
     * @return The stringLengthLt.
     */
    @java.lang.Override
    public long getStringLengthLt() {
      return stringLengthLt_;
    }

    public static final int STRING_LENGTH_EQ_FIELD_NUMBER = 22;
    private long stringLengthEq_ = 0L;
    /**
     * <code>optional int64 string_length_eq = 22;</code>
     * @return Whether the stringLengthEq field is set.
     */
    @java.lang.Override
    public boolean hasStringLengthEq() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <code>optional int64 string_length_eq = 22;</code>
     * @return The stringLengthEq.
     */
    @java.lang.Override
    public long getStringLengthEq() {
      return stringLengthEq_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, regex_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt64(2, intGt_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt64(3, intLt_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(4, msgExists_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, humanError_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeDouble(6, floatGt_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeDouble(7, floatLt_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeDouble(8, floatEpsilon_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeDouble(9, floatGte_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeDouble(10, floatLte_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeBool(11, stringNotEmpty_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeInt64(12, repeatedCountMin_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeInt64(13, repeatedCountMax_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeInt64(14, lengthGt_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeInt64(15, lengthLt_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeInt64(16, lengthEq_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        output.writeBool(17, isInEnum_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        output.writeInt32(18, uuidVer_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(19, required_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        output.writeInt64(20, stringLengthGt_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        output.writeInt64(21, stringLengthLt_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        output.writeInt64(22, stringLengthEq_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, regex_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, intGt_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, intLt_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, msgExists_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, humanError_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(6, floatGt_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(7, floatLt_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(8, floatEpsilon_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(9, floatGte_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(10, floatLte_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, stringNotEmpty_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(12, repeatedCountMin_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(13, repeatedCountMax_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(14, lengthGt_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(15, lengthLt_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(16, lengthEq_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(17, isInEnum_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(18, uuidVer_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(19, required_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(20, stringLengthGt_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(21, stringLengthLt_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(22, stringLengthEq_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof validator.Validator.FieldValidator)) {
        return super.equals(obj);
      }
      validator.Validator.FieldValidator other = (validator.Validator.FieldValidator) obj;

      if (hasRegex() != other.hasRegex()) return false;
      if (hasRegex()) {
        if (!getRegex()
            .equals(other.getRegex())) return false;
      }
      if (hasIntGt() != other.hasIntGt()) return false;
      if (hasIntGt()) {
        if (getIntGt()
            != other.getIntGt()) return false;
      }
      if (hasIntLt() != other.hasIntLt()) return false;
      if (hasIntLt()) {
        if (getIntLt()
            != other.getIntLt()) return false;
      }
      if (hasMsgExists() != other.hasMsgExists()) return false;
      if (hasMsgExists()) {
        if (getMsgExists()
            != other.getMsgExists()) return false;
      }
      if (hasRequired() != other.hasRequired()) return false;
      if (hasRequired()) {
        if (getRequired()
            != other.getRequired()) return false;
      }
      if (hasHumanError() != other.hasHumanError()) return false;
      if (hasHumanError()) {
        if (!getHumanError()
            .equals(other.getHumanError())) return false;
      }
      if (hasFloatGt() != other.hasFloatGt()) return false;
      if (hasFloatGt()) {
        if (java.lang.Double.doubleToLongBits(getFloatGt())
            != java.lang.Double.doubleToLongBits(
                other.getFloatGt())) return false;
      }
      if (hasFloatLt() != other.hasFloatLt()) return false;
      if (hasFloatLt()) {
        if (java.lang.Double.doubleToLongBits(getFloatLt())
            != java.lang.Double.doubleToLongBits(
                other.getFloatLt())) return false;
      }
      if (hasFloatEpsilon() != other.hasFloatEpsilon()) return false;
      if (hasFloatEpsilon()) {
        if (java.lang.Double.doubleToLongBits(getFloatEpsilon())
            != java.lang.Double.doubleToLongBits(
                other.getFloatEpsilon())) return false;
      }
      if (hasFloatGte() != other.hasFloatGte()) return false;
      if (hasFloatGte()) {
        if (java.lang.Double.doubleToLongBits(getFloatGte())
            != java.lang.Double.doubleToLongBits(
                other.getFloatGte())) return false;
      }
      if (hasFloatLte() != other.hasFloatLte()) return false;
      if (hasFloatLte()) {
        if (java.lang.Double.doubleToLongBits(getFloatLte())
            != java.lang.Double.doubleToLongBits(
                other.getFloatLte())) return false;
      }
      if (hasStringNotEmpty() != other.hasStringNotEmpty()) return false;
      if (hasStringNotEmpty()) {
        if (getStringNotEmpty()
            != other.getStringNotEmpty()) return false;
      }
      if (hasRepeatedCountMin() != other.hasRepeatedCountMin()) return false;
      if (hasRepeatedCountMin()) {
        if (getRepeatedCountMin()
            != other.getRepeatedCountMin()) return false;
      }
      if (hasRepeatedCountMax() != other.hasRepeatedCountMax()) return false;
      if (hasRepeatedCountMax()) {
        if (getRepeatedCountMax()
            != other.getRepeatedCountMax()) return false;
      }
      if (hasLengthGt() != other.hasLengthGt()) return false;
      if (hasLengthGt()) {
        if (getLengthGt()
            != other.getLengthGt()) return false;
      }
      if (hasLengthLt() != other.hasLengthLt()) return false;
      if (hasLengthLt()) {
        if (getLengthLt()
            != other.getLengthLt()) return false;
      }
      if (hasLengthEq() != other.hasLengthEq()) return false;
      if (hasLengthEq()) {
        if (getLengthEq()
            != other.getLengthEq()) return false;
      }
      if (hasIsInEnum() != other.hasIsInEnum()) return false;
      if (hasIsInEnum()) {
        if (getIsInEnum()
            != other.getIsInEnum()) return false;
      }
      if (hasUuidVer() != other.hasUuidVer()) return false;
      if (hasUuidVer()) {
        if (getUuidVer()
            != other.getUuidVer()) return false;
      }
      if (hasStringLengthGt() != other.hasStringLengthGt()) return false;
      if (hasStringLengthGt()) {
        if (getStringLengthGt()
            != other.getStringLengthGt()) return false;
      }
      if (hasStringLengthLt() != other.hasStringLengthLt()) return false;
      if (hasStringLengthLt()) {
        if (getStringLengthLt()
            != other.getStringLengthLt()) return false;
      }
      if (hasStringLengthEq() != other.hasStringLengthEq()) return false;
      if (hasStringLengthEq()) {
        if (getStringLengthEq()
            != other.getStringLengthEq()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRegex()) {
        hash = (37 * hash) + REGEX_FIELD_NUMBER;
        hash = (53 * hash) + getRegex().hashCode();
      }
      if (hasIntGt()) {
        hash = (37 * hash) + INT_GT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getIntGt());
      }
      if (hasIntLt()) {
        hash = (37 * hash) + INT_LT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getIntLt());
      }
      if (hasMsgExists()) {
        hash = (37 * hash) + MSG_EXISTS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getMsgExists());
      }
      if (hasRequired()) {
        hash = (37 * hash) + REQUIRED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRequired());
      }
      if (hasHumanError()) {
        hash = (37 * hash) + HUMAN_ERROR_FIELD_NUMBER;
        hash = (53 * hash) + getHumanError().hashCode();
      }
      if (hasFloatGt()) {
        hash = (37 * hash) + FLOAT_GT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            java.lang.Double.doubleToLongBits(getFloatGt()));
      }
      if (hasFloatLt()) {
        hash = (37 * hash) + FLOAT_LT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            java.lang.Double.doubleToLongBits(getFloatLt()));
      }
      if (hasFloatEpsilon()) {
        hash = (37 * hash) + FLOAT_EPSILON_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            java.lang.Double.doubleToLongBits(getFloatEpsilon()));
      }
      if (hasFloatGte()) {
        hash = (37 * hash) + FLOAT_GTE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            java.lang.Double.doubleToLongBits(getFloatGte()));
      }
      if (hasFloatLte()) {
        hash = (37 * hash) + FLOAT_LTE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            java.lang.Double.doubleToLongBits(getFloatLte()));
      }
      if (hasStringNotEmpty()) {
        hash = (37 * hash) + STRING_NOT_EMPTY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getStringNotEmpty());
      }
      if (hasRepeatedCountMin()) {
        hash = (37 * hash) + REPEATED_COUNT_MIN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getRepeatedCountMin());
      }
      if (hasRepeatedCountMax()) {
        hash = (37 * hash) + REPEATED_COUNT_MAX_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getRepeatedCountMax());
      }
      if (hasLengthGt()) {
        hash = (37 * hash) + LENGTH_GT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getLengthGt());
      }
      if (hasLengthLt()) {
        hash = (37 * hash) + LENGTH_LT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getLengthLt());
      }
      if (hasLengthEq()) {
        hash = (37 * hash) + LENGTH_EQ_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getLengthEq());
      }
      if (hasIsInEnum()) {
        hash = (37 * hash) + IS_IN_ENUM_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsInEnum());
      }
      if (hasUuidVer()) {
        hash = (37 * hash) + UUID_VER_FIELD_NUMBER;
        hash = (53 * hash) + getUuidVer();
      }
      if (hasStringLengthGt()) {
        hash = (37 * hash) + STRING_LENGTH_GT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStringLengthGt());
      }
      if (hasStringLengthLt()) {
        hash = (37 * hash) + STRING_LENGTH_LT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStringLengthLt());
      }
      if (hasStringLengthEq()) {
        hash = (37 * hash) + STRING_LENGTH_EQ_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStringLengthEq());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static validator.Validator.FieldValidator parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static validator.Validator.FieldValidator parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static validator.Validator.FieldValidator parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static validator.Validator.FieldValidator parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static validator.Validator.FieldValidator parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static validator.Validator.FieldValidator parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static validator.Validator.FieldValidator parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static validator.Validator.FieldValidator parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static validator.Validator.FieldValidator parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static validator.Validator.FieldValidator parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static validator.Validator.FieldValidator parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static validator.Validator.FieldValidator parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(validator.Validator.FieldValidator prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code validator.FieldValidator}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:validator.FieldValidator)
        validator.Validator.FieldValidatorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return validator.Validator.internal_static_validator_FieldValidator_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return validator.Validator.internal_static_validator_FieldValidator_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                validator.Validator.FieldValidator.class, validator.Validator.FieldValidator.Builder.class);
      }

      // Construct using validator.Validator.FieldValidator.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        regex_ = "";
        intGt_ = 0L;
        intLt_ = 0L;
        msgExists_ = false;
        required_ = false;
        humanError_ = "";
        floatGt_ = 0D;
        floatLt_ = 0D;
        floatEpsilon_ = 0D;
        floatGte_ = 0D;
        floatLte_ = 0D;
        stringNotEmpty_ = false;
        repeatedCountMin_ = 0L;
        repeatedCountMax_ = 0L;
        lengthGt_ = 0L;
        lengthLt_ = 0L;
        lengthEq_ = 0L;
        isInEnum_ = false;
        uuidVer_ = 0;
        stringLengthGt_ = 0L;
        stringLengthLt_ = 0L;
        stringLengthEq_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return validator.Validator.internal_static_validator_FieldValidator_descriptor;
      }

      @java.lang.Override
      public validator.Validator.FieldValidator getDefaultInstanceForType() {
        return validator.Validator.FieldValidator.getDefaultInstance();
      }

      @java.lang.Override
      public validator.Validator.FieldValidator build() {
        validator.Validator.FieldValidator result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public validator.Validator.FieldValidator buildPartial() {
        validator.Validator.FieldValidator result = new validator.Validator.FieldValidator(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(validator.Validator.FieldValidator result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.regex_ = regex_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.intGt_ = intGt_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.intLt_ = intLt_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.msgExists_ = msgExists_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.required_ = required_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.humanError_ = humanError_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.floatGt_ = floatGt_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.floatLt_ = floatLt_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.floatEpsilon_ = floatEpsilon_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.floatGte_ = floatGte_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.floatLte_ = floatLte_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.stringNotEmpty_ = stringNotEmpty_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.repeatedCountMin_ = repeatedCountMin_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.repeatedCountMax_ = repeatedCountMax_;
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.lengthGt_ = lengthGt_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.lengthLt_ = lengthLt_;
          to_bitField0_ |= 0x00008000;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.lengthEq_ = lengthEq_;
          to_bitField0_ |= 0x00010000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.isInEnum_ = isInEnum_;
          to_bitField0_ |= 0x00020000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.uuidVer_ = uuidVer_;
          to_bitField0_ |= 0x00040000;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          result.stringLengthGt_ = stringLengthGt_;
          to_bitField0_ |= 0x00080000;
        }
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.stringLengthLt_ = stringLengthLt_;
          to_bitField0_ |= 0x00100000;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          result.stringLengthEq_ = stringLengthEq_;
          to_bitField0_ |= 0x00200000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof validator.Validator.FieldValidator) {
          return mergeFrom((validator.Validator.FieldValidator)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(validator.Validator.FieldValidator other) {
        if (other == validator.Validator.FieldValidator.getDefaultInstance()) return this;
        if (other.hasRegex()) {
          regex_ = other.regex_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasIntGt()) {
          setIntGt(other.getIntGt());
        }
        if (other.hasIntLt()) {
          setIntLt(other.getIntLt());
        }
        if (other.hasMsgExists()) {
          setMsgExists(other.getMsgExists());
        }
        if (other.hasRequired()) {
          setRequired(other.getRequired());
        }
        if (other.hasHumanError()) {
          humanError_ = other.humanError_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (other.hasFloatGt()) {
          setFloatGt(other.getFloatGt());
        }
        if (other.hasFloatLt()) {
          setFloatLt(other.getFloatLt());
        }
        if (other.hasFloatEpsilon()) {
          setFloatEpsilon(other.getFloatEpsilon());
        }
        if (other.hasFloatGte()) {
          setFloatGte(other.getFloatGte());
        }
        if (other.hasFloatLte()) {
          setFloatLte(other.getFloatLte());
        }
        if (other.hasStringNotEmpty()) {
          setStringNotEmpty(other.getStringNotEmpty());
        }
        if (other.hasRepeatedCountMin()) {
          setRepeatedCountMin(other.getRepeatedCountMin());
        }
        if (other.hasRepeatedCountMax()) {
          setRepeatedCountMax(other.getRepeatedCountMax());
        }
        if (other.hasLengthGt()) {
          setLengthGt(other.getLengthGt());
        }
        if (other.hasLengthLt()) {
          setLengthLt(other.getLengthLt());
        }
        if (other.hasLengthEq()) {
          setLengthEq(other.getLengthEq());
        }
        if (other.hasIsInEnum()) {
          setIsInEnum(other.getIsInEnum());
        }
        if (other.hasUuidVer()) {
          setUuidVer(other.getUuidVer());
        }
        if (other.hasStringLengthGt()) {
          setStringLengthGt(other.getStringLengthGt());
        }
        if (other.hasStringLengthLt()) {
          setStringLengthLt(other.getStringLengthLt());
        }
        if (other.hasStringLengthEq()) {
          setStringLengthEq(other.getStringLengthEq());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                regex_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                intGt_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                intLt_ = input.readInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                msgExists_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 42: {
                humanError_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 42
              case 49: {
                floatGt_ = input.readDouble();
                bitField0_ |= 0x00000040;
                break;
              } // case 49
              case 57: {
                floatLt_ = input.readDouble();
                bitField0_ |= 0x00000080;
                break;
              } // case 57
              case 65: {
                floatEpsilon_ = input.readDouble();
                bitField0_ |= 0x00000100;
                break;
              } // case 65
              case 73: {
                floatGte_ = input.readDouble();
                bitField0_ |= 0x00000200;
                break;
              } // case 73
              case 81: {
                floatLte_ = input.readDouble();
                bitField0_ |= 0x00000400;
                break;
              } // case 81
              case 88: {
                stringNotEmpty_ = input.readBool();
                bitField0_ |= 0x00000800;
                break;
              } // case 88
              case 96: {
                repeatedCountMin_ = input.readInt64();
                bitField0_ |= 0x00001000;
                break;
              } // case 96
              case 104: {
                repeatedCountMax_ = input.readInt64();
                bitField0_ |= 0x00002000;
                break;
              } // case 104
              case 112: {
                lengthGt_ = input.readInt64();
                bitField0_ |= 0x00004000;
                break;
              } // case 112
              case 120: {
                lengthLt_ = input.readInt64();
                bitField0_ |= 0x00008000;
                break;
              } // case 120
              case 128: {
                lengthEq_ = input.readInt64();
                bitField0_ |= 0x00010000;
                break;
              } // case 128
              case 136: {
                isInEnum_ = input.readBool();
                bitField0_ |= 0x00020000;
                break;
              } // case 136
              case 144: {
                uuidVer_ = input.readInt32();
                bitField0_ |= 0x00040000;
                break;
              } // case 144
              case 152: {
                required_ = input.readBool();
                bitField0_ |= 0x00000010;
                break;
              } // case 152
              case 160: {
                stringLengthGt_ = input.readInt64();
                bitField0_ |= 0x00080000;
                break;
              } // case 160
              case 168: {
                stringLengthLt_ = input.readInt64();
                bitField0_ |= 0x00100000;
                break;
              } // case 168
              case 176: {
                stringLengthEq_ = input.readInt64();
                bitField0_ |= 0x00200000;
                break;
              } // case 176
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object regex_ = "";
      /**
       * <pre>
       * Uses a Golang RE2-syntax regex to match the field contents.
       * </pre>
       *
       * <code>optional string regex = 1;</code>
       * @return Whether the regex field is set.
       */
      public boolean hasRegex() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Uses a Golang RE2-syntax regex to match the field contents.
       * </pre>
       *
       * <code>optional string regex = 1;</code>
       * @return The regex.
       */
      public java.lang.String getRegex() {
        java.lang.Object ref = regex_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            regex_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Uses a Golang RE2-syntax regex to match the field contents.
       * </pre>
       *
       * <code>optional string regex = 1;</code>
       * @return The bytes for regex.
       */
      public com.google.protobuf.ByteString
          getRegexBytes() {
        java.lang.Object ref = regex_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          regex_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Uses a Golang RE2-syntax regex to match the field contents.
       * </pre>
       *
       * <code>optional string regex = 1;</code>
       * @param value The regex to set.
       * @return This builder for chaining.
       */
      public Builder setRegex(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        regex_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Uses a Golang RE2-syntax regex to match the field contents.
       * </pre>
       *
       * <code>optional string regex = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRegex() {
        regex_ = getDefaultInstance().getRegex();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Uses a Golang RE2-syntax regex to match the field contents.
       * </pre>
       *
       * <code>optional string regex = 1;</code>
       * @param value The bytes for regex to set.
       * @return This builder for chaining.
       */
      public Builder setRegexBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        regex_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private long intGt_ ;
      /**
       * <pre>
       * Field value of integer strictly greater than this value.
       * </pre>
       *
       * <code>optional int64 int_gt = 2;</code>
       * @return Whether the intGt field is set.
       */
      @java.lang.Override
      public boolean hasIntGt() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Field value of integer strictly greater than this value.
       * </pre>
       *
       * <code>optional int64 int_gt = 2;</code>
       * @return The intGt.
       */
      @java.lang.Override
      public long getIntGt() {
        return intGt_;
      }
      /**
       * <pre>
       * Field value of integer strictly greater than this value.
       * </pre>
       *
       * <code>optional int64 int_gt = 2;</code>
       * @param value The intGt to set.
       * @return This builder for chaining.
       */
      public Builder setIntGt(long value) {

        intGt_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Field value of integer strictly greater than this value.
       * </pre>
       *
       * <code>optional int64 int_gt = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearIntGt() {
        bitField0_ = (bitField0_ & ~0x00000002);
        intGt_ = 0L;
        onChanged();
        return this;
      }

      private long intLt_ ;
      /**
       * <pre>
       * Field value of integer strictly smaller than this value.
       * </pre>
       *
       * <code>optional int64 int_lt = 3;</code>
       * @return Whether the intLt field is set.
       */
      @java.lang.Override
      public boolean hasIntLt() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Field value of integer strictly smaller than this value.
       * </pre>
       *
       * <code>optional int64 int_lt = 3;</code>
       * @return The intLt.
       */
      @java.lang.Override
      public long getIntLt() {
        return intLt_;
      }
      /**
       * <pre>
       * Field value of integer strictly smaller than this value.
       * </pre>
       *
       * <code>optional int64 int_lt = 3;</code>
       * @param value The intLt to set.
       * @return This builder for chaining.
       */
      public Builder setIntLt(long value) {

        intLt_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Field value of integer strictly smaller than this value.
       * </pre>
       *
       * <code>optional int64 int_lt = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIntLt() {
        bitField0_ = (bitField0_ & ~0x00000004);
        intLt_ = 0L;
        onChanged();
        return this;
      }

      private boolean msgExists_ ;
      /**
       * <pre>
       * Used for nested message types, requires that the message type exists.
       * </pre>
       *
       * <code>optional bool msg_exists = 4;</code>
       * @return Whether the msgExists field is set.
       */
      @java.lang.Override
      public boolean hasMsgExists() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Used for nested message types, requires that the message type exists.
       * </pre>
       *
       * <code>optional bool msg_exists = 4;</code>
       * @return The msgExists.
       */
      @java.lang.Override
      public boolean getMsgExists() {
        return msgExists_;
      }
      /**
       * <pre>
       * Used for nested message types, requires that the message type exists.
       * </pre>
       *
       * <code>optional bool msg_exists = 4;</code>
       * @param value The msgExists to set.
       * @return This builder for chaining.
       */
      public Builder setMsgExists(boolean value) {

        msgExists_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Used for nested message types, requires that the message type exists.
       * </pre>
       *
       * <code>optional bool msg_exists = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsgExists() {
        bitField0_ = (bitField0_ & ~0x00000008);
        msgExists_ = false;
        onChanged();
        return this;
      }

      private boolean required_ ;
      /**
       * <pre>
       * 必填参数，参数非零值
       * </pre>
       *
       * <code>optional bool required = 19;</code>
       * @return Whether the required field is set.
       */
      @java.lang.Override
      public boolean hasRequired() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * 必填参数，参数非零值
       * </pre>
       *
       * <code>optional bool required = 19;</code>
       * @return The required.
       */
      @java.lang.Override
      public boolean getRequired() {
        return required_;
      }
      /**
       * <pre>
       * 必填参数，参数非零值
       * </pre>
       *
       * <code>optional bool required = 19;</code>
       * @param value The required to set.
       * @return This builder for chaining.
       */
      public Builder setRequired(boolean value) {

        required_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * 必填参数，参数非零值
       * </pre>
       *
       * <code>optional bool required = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearRequired() {
        bitField0_ = (bitField0_ & ~0x00000010);
        required_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object humanError_ = "";
      /**
       * <pre>
       * Human error specifies a user-customizable error that is visible to the user.
       * </pre>
       *
       * <code>optional string human_error = 5;</code>
       * @return Whether the humanError field is set.
       */
      public boolean hasHumanError() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Human error specifies a user-customizable error that is visible to the user.
       * </pre>
       *
       * <code>optional string human_error = 5;</code>
       * @return The humanError.
       */
      public java.lang.String getHumanError() {
        java.lang.Object ref = humanError_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            humanError_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Human error specifies a user-customizable error that is visible to the user.
       * </pre>
       *
       * <code>optional string human_error = 5;</code>
       * @return The bytes for humanError.
       */
      public com.google.protobuf.ByteString
          getHumanErrorBytes() {
        java.lang.Object ref = humanError_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          humanError_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Human error specifies a user-customizable error that is visible to the user.
       * </pre>
       *
       * <code>optional string human_error = 5;</code>
       * @param value The humanError to set.
       * @return This builder for chaining.
       */
      public Builder setHumanError(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        humanError_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Human error specifies a user-customizable error that is visible to the user.
       * </pre>
       *
       * <code>optional string human_error = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearHumanError() {
        humanError_ = getDefaultInstance().getHumanError();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Human error specifies a user-customizable error that is visible to the user.
       * </pre>
       *
       * <code>optional string human_error = 5;</code>
       * @param value The bytes for humanError to set.
       * @return This builder for chaining.
       */
      public Builder setHumanErrorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        humanError_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private double floatGt_ ;
      /**
       * <pre>
       * Field value of double strictly greater than this value.
       * Note that this value can only take on a valid floating point
       * value. Use together with float_epsilon if you need something more specific.
       * </pre>
       *
       * <code>optional double float_gt = 6;</code>
       * @return Whether the floatGt field is set.
       */
      @java.lang.Override
      public boolean hasFloatGt() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Field value of double strictly greater than this value.
       * Note that this value can only take on a valid floating point
       * value. Use together with float_epsilon if you need something more specific.
       * </pre>
       *
       * <code>optional double float_gt = 6;</code>
       * @return The floatGt.
       */
      @java.lang.Override
      public double getFloatGt() {
        return floatGt_;
      }
      /**
       * <pre>
       * Field value of double strictly greater than this value.
       * Note that this value can only take on a valid floating point
       * value. Use together with float_epsilon if you need something more specific.
       * </pre>
       *
       * <code>optional double float_gt = 6;</code>
       * @param value The floatGt to set.
       * @return This builder for chaining.
       */
      public Builder setFloatGt(double value) {

        floatGt_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Field value of double strictly greater than this value.
       * Note that this value can only take on a valid floating point
       * value. Use together with float_epsilon if you need something more specific.
       * </pre>
       *
       * <code>optional double float_gt = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearFloatGt() {
        bitField0_ = (bitField0_ & ~0x00000040);
        floatGt_ = 0D;
        onChanged();
        return this;
      }

      private double floatLt_ ;
      /**
       * <pre>
       * Field value of double strictly smaller than this value.
       * Note that this value can only take on a valid floating point
       * value. Use together with float_epsilon if you need something more specific.
       * </pre>
       *
       * <code>optional double float_lt = 7;</code>
       * @return Whether the floatLt field is set.
       */
      @java.lang.Override
      public boolean hasFloatLt() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Field value of double strictly smaller than this value.
       * Note that this value can only take on a valid floating point
       * value. Use together with float_epsilon if you need something more specific.
       * </pre>
       *
       * <code>optional double float_lt = 7;</code>
       * @return The floatLt.
       */
      @java.lang.Override
      public double getFloatLt() {
        return floatLt_;
      }
      /**
       * <pre>
       * Field value of double strictly smaller than this value.
       * Note that this value can only take on a valid floating point
       * value. Use together with float_epsilon if you need something more specific.
       * </pre>
       *
       * <code>optional double float_lt = 7;</code>
       * @param value The floatLt to set.
       * @return This builder for chaining.
       */
      public Builder setFloatLt(double value) {

        floatLt_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Field value of double strictly smaller than this value.
       * Note that this value can only take on a valid floating point
       * value. Use together with float_epsilon if you need something more specific.
       * </pre>
       *
       * <code>optional double float_lt = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearFloatLt() {
        bitField0_ = (bitField0_ & ~0x00000080);
        floatLt_ = 0D;
        onChanged();
        return this;
      }

      private double floatEpsilon_ ;
      /**
       * <pre>
       * Field value of double describing the epsilon within which
       * any comparison should be considered to be true. For example,
       * when using float_gt = 0.35, using a float_epsilon of 0.05
       * would mean that any value above 0.30 is acceptable. It can be
       * thought of as a {float_value_condition} +- {float_epsilon}.
       * If unset, no correction for floating point inaccuracies in
       * comparisons will be attempted.
       * </pre>
       *
       * <code>optional double float_epsilon = 8;</code>
       * @return Whether the floatEpsilon field is set.
       */
      @java.lang.Override
      public boolean hasFloatEpsilon() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Field value of double describing the epsilon within which
       * any comparison should be considered to be true. For example,
       * when using float_gt = 0.35, using a float_epsilon of 0.05
       * would mean that any value above 0.30 is acceptable. It can be
       * thought of as a {float_value_condition} +- {float_epsilon}.
       * If unset, no correction for floating point inaccuracies in
       * comparisons will be attempted.
       * </pre>
       *
       * <code>optional double float_epsilon = 8;</code>
       * @return The floatEpsilon.
       */
      @java.lang.Override
      public double getFloatEpsilon() {
        return floatEpsilon_;
      }
      /**
       * <pre>
       * Field value of double describing the epsilon within which
       * any comparison should be considered to be true. For example,
       * when using float_gt = 0.35, using a float_epsilon of 0.05
       * would mean that any value above 0.30 is acceptable. It can be
       * thought of as a {float_value_condition} +- {float_epsilon}.
       * If unset, no correction for floating point inaccuracies in
       * comparisons will be attempted.
       * </pre>
       *
       * <code>optional double float_epsilon = 8;</code>
       * @param value The floatEpsilon to set.
       * @return This builder for chaining.
       */
      public Builder setFloatEpsilon(double value) {

        floatEpsilon_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Field value of double describing the epsilon within which
       * any comparison should be considered to be true. For example,
       * when using float_gt = 0.35, using a float_epsilon of 0.05
       * would mean that any value above 0.30 is acceptable. It can be
       * thought of as a {float_value_condition} +- {float_epsilon}.
       * If unset, no correction for floating point inaccuracies in
       * comparisons will be attempted.
       * </pre>
       *
       * <code>optional double float_epsilon = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearFloatEpsilon() {
        bitField0_ = (bitField0_ & ~0x00000100);
        floatEpsilon_ = 0D;
        onChanged();
        return this;
      }

      private double floatGte_ ;
      /**
       * <pre>
       * Floating-point value compared to which the field content should be greater or equal.
       * </pre>
       *
       * <code>optional double float_gte = 9;</code>
       * @return Whether the floatGte field is set.
       */
      @java.lang.Override
      public boolean hasFloatGte() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Floating-point value compared to which the field content should be greater or equal.
       * </pre>
       *
       * <code>optional double float_gte = 9;</code>
       * @return The floatGte.
       */
      @java.lang.Override
      public double getFloatGte() {
        return floatGte_;
      }
      /**
       * <pre>
       * Floating-point value compared to which the field content should be greater or equal.
       * </pre>
       *
       * <code>optional double float_gte = 9;</code>
       * @param value The floatGte to set.
       * @return This builder for chaining.
       */
      public Builder setFloatGte(double value) {

        floatGte_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Floating-point value compared to which the field content should be greater or equal.
       * </pre>
       *
       * <code>optional double float_gte = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearFloatGte() {
        bitField0_ = (bitField0_ & ~0x00000200);
        floatGte_ = 0D;
        onChanged();
        return this;
      }

      private double floatLte_ ;
      /**
       * <pre>
       * Floating-point value compared to which the field content should be smaller or equal.
       * </pre>
       *
       * <code>optional double float_lte = 10;</code>
       * @return Whether the floatLte field is set.
       */
      @java.lang.Override
      public boolean hasFloatLte() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Floating-point value compared to which the field content should be smaller or equal.
       * </pre>
       *
       * <code>optional double float_lte = 10;</code>
       * @return The floatLte.
       */
      @java.lang.Override
      public double getFloatLte() {
        return floatLte_;
      }
      /**
       * <pre>
       * Floating-point value compared to which the field content should be smaller or equal.
       * </pre>
       *
       * <code>optional double float_lte = 10;</code>
       * @param value The floatLte to set.
       * @return This builder for chaining.
       */
      public Builder setFloatLte(double value) {

        floatLte_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Floating-point value compared to which the field content should be smaller or equal.
       * </pre>
       *
       * <code>optional double float_lte = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearFloatLte() {
        bitField0_ = (bitField0_ & ~0x00000400);
        floatLte_ = 0D;
        onChanged();
        return this;
      }

      private boolean stringNotEmpty_ ;
      /**
       * <pre>
       * Used for string fields, requires the string to be not empty (i.e different from "").
       * </pre>
       *
       * <code>optional bool string_not_empty = 11;</code>
       * @return Whether the stringNotEmpty field is set.
       */
      @java.lang.Override
      public boolean hasStringNotEmpty() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Used for string fields, requires the string to be not empty (i.e different from "").
       * </pre>
       *
       * <code>optional bool string_not_empty = 11;</code>
       * @return The stringNotEmpty.
       */
      @java.lang.Override
      public boolean getStringNotEmpty() {
        return stringNotEmpty_;
      }
      /**
       * <pre>
       * Used for string fields, requires the string to be not empty (i.e different from "").
       * </pre>
       *
       * <code>optional bool string_not_empty = 11;</code>
       * @param value The stringNotEmpty to set.
       * @return This builder for chaining.
       */
      public Builder setStringNotEmpty(boolean value) {

        stringNotEmpty_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Used for string fields, requires the string to be not empty (i.e different from "").
       * </pre>
       *
       * <code>optional bool string_not_empty = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearStringNotEmpty() {
        bitField0_ = (bitField0_ & ~0x00000800);
        stringNotEmpty_ = false;
        onChanged();
        return this;
      }

      private long repeatedCountMin_ ;
      /**
       * <pre>
       * Repeated field with at least this number of elements.
       * </pre>
       *
       * <code>optional int64 repeated_count_min = 12;</code>
       * @return Whether the repeatedCountMin field is set.
       */
      @java.lang.Override
      public boolean hasRepeatedCountMin() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Repeated field with at least this number of elements.
       * </pre>
       *
       * <code>optional int64 repeated_count_min = 12;</code>
       * @return The repeatedCountMin.
       */
      @java.lang.Override
      public long getRepeatedCountMin() {
        return repeatedCountMin_;
      }
      /**
       * <pre>
       * Repeated field with at least this number of elements.
       * </pre>
       *
       * <code>optional int64 repeated_count_min = 12;</code>
       * @param value The repeatedCountMin to set.
       * @return This builder for chaining.
       */
      public Builder setRepeatedCountMin(long value) {

        repeatedCountMin_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Repeated field with at least this number of elements.
       * </pre>
       *
       * <code>optional int64 repeated_count_min = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearRepeatedCountMin() {
        bitField0_ = (bitField0_ & ~0x00001000);
        repeatedCountMin_ = 0L;
        onChanged();
        return this;
      }

      private long repeatedCountMax_ ;
      /**
       * <pre>
       * Repeated field with at most this number of elements.
       * </pre>
       *
       * <code>optional int64 repeated_count_max = 13;</code>
       * @return Whether the repeatedCountMax field is set.
       */
      @java.lang.Override
      public boolean hasRepeatedCountMax() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Repeated field with at most this number of elements.
       * </pre>
       *
       * <code>optional int64 repeated_count_max = 13;</code>
       * @return The repeatedCountMax.
       */
      @java.lang.Override
      public long getRepeatedCountMax() {
        return repeatedCountMax_;
      }
      /**
       * <pre>
       * Repeated field with at most this number of elements.
       * </pre>
       *
       * <code>optional int64 repeated_count_max = 13;</code>
       * @param value The repeatedCountMax to set.
       * @return This builder for chaining.
       */
      public Builder setRepeatedCountMax(long value) {

        repeatedCountMax_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Repeated field with at most this number of elements.
       * </pre>
       *
       * <code>optional int64 repeated_count_max = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearRepeatedCountMax() {
        bitField0_ = (bitField0_ & ~0x00002000);
        repeatedCountMax_ = 0L;
        onChanged();
        return this;
      }

      private long lengthGt_ ;
      /**
       * <pre>
       * Field value of length greater than this value.
       * </pre>
       *
       * <code>optional int64 length_gt = 14;</code>
       * @return Whether the lengthGt field is set.
       */
      @java.lang.Override
      public boolean hasLengthGt() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Field value of length greater than this value.
       * </pre>
       *
       * <code>optional int64 length_gt = 14;</code>
       * @return The lengthGt.
       */
      @java.lang.Override
      public long getLengthGt() {
        return lengthGt_;
      }
      /**
       * <pre>
       * Field value of length greater than this value.
       * </pre>
       *
       * <code>optional int64 length_gt = 14;</code>
       * @param value The lengthGt to set.
       * @return This builder for chaining.
       */
      public Builder setLengthGt(long value) {

        lengthGt_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Field value of length greater than this value.
       * </pre>
       *
       * <code>optional int64 length_gt = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearLengthGt() {
        bitField0_ = (bitField0_ & ~0x00004000);
        lengthGt_ = 0L;
        onChanged();
        return this;
      }

      private long lengthLt_ ;
      /**
       * <pre>
       * Field value of length smaller than this value.
       * </pre>
       *
       * <code>optional int64 length_lt = 15;</code>
       * @return Whether the lengthLt field is set.
       */
      @java.lang.Override
      public boolean hasLengthLt() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * Field value of length smaller than this value.
       * </pre>
       *
       * <code>optional int64 length_lt = 15;</code>
       * @return The lengthLt.
       */
      @java.lang.Override
      public long getLengthLt() {
        return lengthLt_;
      }
      /**
       * <pre>
       * Field value of length smaller than this value.
       * </pre>
       *
       * <code>optional int64 length_lt = 15;</code>
       * @param value The lengthLt to set.
       * @return This builder for chaining.
       */
      public Builder setLengthLt(long value) {

        lengthLt_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Field value of length smaller than this value.
       * </pre>
       *
       * <code>optional int64 length_lt = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearLengthLt() {
        bitField0_ = (bitField0_ & ~0x00008000);
        lengthLt_ = 0L;
        onChanged();
        return this;
      }

      private long lengthEq_ ;
      /**
       * <pre>
       * Field value of length strictly equal to this value.
       * </pre>
       *
       * <code>optional int64 length_eq = 16;</code>
       * @return Whether the lengthEq field is set.
       */
      @java.lang.Override
      public boolean hasLengthEq() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * Field value of length strictly equal to this value.
       * </pre>
       *
       * <code>optional int64 length_eq = 16;</code>
       * @return The lengthEq.
       */
      @java.lang.Override
      public long getLengthEq() {
        return lengthEq_;
      }
      /**
       * <pre>
       * Field value of length strictly equal to this value.
       * </pre>
       *
       * <code>optional int64 length_eq = 16;</code>
       * @param value The lengthEq to set.
       * @return This builder for chaining.
       */
      public Builder setLengthEq(long value) {

        lengthEq_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Field value of length strictly equal to this value.
       * </pre>
       *
       * <code>optional int64 length_eq = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearLengthEq() {
        bitField0_ = (bitField0_ & ~0x00010000);
        lengthEq_ = 0L;
        onChanged();
        return this;
      }

      private boolean isInEnum_ ;
      /**
       * <pre>
       * Requires that the value is in the enum.
       * </pre>
       *
       * <code>optional bool is_in_enum = 17;</code>
       * @return Whether the isInEnum field is set.
       */
      @java.lang.Override
      public boolean hasIsInEnum() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Requires that the value is in the enum.
       * </pre>
       *
       * <code>optional bool is_in_enum = 17;</code>
       * @return The isInEnum.
       */
      @java.lang.Override
      public boolean getIsInEnum() {
        return isInEnum_;
      }
      /**
       * <pre>
       * Requires that the value is in the enum.
       * </pre>
       *
       * <code>optional bool is_in_enum = 17;</code>
       * @param value The isInEnum to set.
       * @return This builder for chaining.
       */
      public Builder setIsInEnum(boolean value) {

        isInEnum_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Requires that the value is in the enum.
       * </pre>
       *
       * <code>optional bool is_in_enum = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsInEnum() {
        bitField0_ = (bitField0_ & ~0x00020000);
        isInEnum_ = false;
        onChanged();
        return this;
      }

      private int uuidVer_ ;
      /**
       * <pre>
       * Ensures that a string value is in UUID format.
       * uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
       * If uuid_ver is 0 all UUID versions are accepted.
       * </pre>
       *
       * <code>optional int32 uuid_ver = 18;</code>
       * @return Whether the uuidVer field is set.
       */
      @java.lang.Override
      public boolean hasUuidVer() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * Ensures that a string value is in UUID format.
       * uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
       * If uuid_ver is 0 all UUID versions are accepted.
       * </pre>
       *
       * <code>optional int32 uuid_ver = 18;</code>
       * @return The uuidVer.
       */
      @java.lang.Override
      public int getUuidVer() {
        return uuidVer_;
      }
      /**
       * <pre>
       * Ensures that a string value is in UUID format.
       * uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
       * If uuid_ver is 0 all UUID versions are accepted.
       * </pre>
       *
       * <code>optional int32 uuid_ver = 18;</code>
       * @param value The uuidVer to set.
       * @return This builder for chaining.
       */
      public Builder setUuidVer(int value) {

        uuidVer_ = value;
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ensures that a string value is in UUID format.
       * uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
       * If uuid_ver is 0 all UUID versions are accepted.
       * </pre>
       *
       * <code>optional int32 uuid_ver = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearUuidVer() {
        bitField0_ = (bitField0_ & ~0x00040000);
        uuidVer_ = 0;
        onChanged();
        return this;
      }

      private long stringLengthGt_ ;
      /**
       * <pre>
       * 字符串长度大于，属于字符串文字长度
       * </pre>
       *
       * <code>optional int64 string_length_gt = 20;</code>
       * @return Whether the stringLengthGt field is set.
       */
      @java.lang.Override
      public boolean hasStringLengthGt() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <pre>
       * 字符串长度大于，属于字符串文字长度
       * </pre>
       *
       * <code>optional int64 string_length_gt = 20;</code>
       * @return The stringLengthGt.
       */
      @java.lang.Override
      public long getStringLengthGt() {
        return stringLengthGt_;
      }
      /**
       * <pre>
       * 字符串长度大于，属于字符串文字长度
       * </pre>
       *
       * <code>optional int64 string_length_gt = 20;</code>
       * @param value The stringLengthGt to set.
       * @return This builder for chaining.
       */
      public Builder setStringLengthGt(long value) {

        stringLengthGt_ = value;
        bitField0_ |= 0x00080000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * 字符串长度大于，属于字符串文字长度
       * </pre>
       *
       * <code>optional int64 string_length_gt = 20;</code>
       * @return This builder for chaining.
       */
      public Builder clearStringLengthGt() {
        bitField0_ = (bitField0_ & ~0x00080000);
        stringLengthGt_ = 0L;
        onChanged();
        return this;
      }

      private long stringLengthLt_ ;
      /**
       * <code>optional int64 string_length_lt = 21;</code>
       * @return Whether the stringLengthLt field is set.
       */
      @java.lang.Override
      public boolean hasStringLengthLt() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <code>optional int64 string_length_lt = 21;</code>
       * @return The stringLengthLt.
       */
      @java.lang.Override
      public long getStringLengthLt() {
        return stringLengthLt_;
      }
      /**
       * <code>optional int64 string_length_lt = 21;</code>
       * @param value The stringLengthLt to set.
       * @return This builder for chaining.
       */
      public Builder setStringLengthLt(long value) {

        stringLengthLt_ = value;
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 string_length_lt = 21;</code>
       * @return This builder for chaining.
       */
      public Builder clearStringLengthLt() {
        bitField0_ = (bitField0_ & ~0x00100000);
        stringLengthLt_ = 0L;
        onChanged();
        return this;
      }

      private long stringLengthEq_ ;
      /**
       * <code>optional int64 string_length_eq = 22;</code>
       * @return Whether the stringLengthEq field is set.
       */
      @java.lang.Override
      public boolean hasStringLengthEq() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <code>optional int64 string_length_eq = 22;</code>
       * @return The stringLengthEq.
       */
      @java.lang.Override
      public long getStringLengthEq() {
        return stringLengthEq_;
      }
      /**
       * <code>optional int64 string_length_eq = 22;</code>
       * @param value The stringLengthEq to set.
       * @return This builder for chaining.
       */
      public Builder setStringLengthEq(long value) {

        stringLengthEq_ = value;
        bitField0_ |= 0x00200000;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 string_length_eq = 22;</code>
       * @return This builder for chaining.
       */
      public Builder clearStringLengthEq() {
        bitField0_ = (bitField0_ & ~0x00200000);
        stringLengthEq_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:validator.FieldValidator)
    }

    // @@protoc_insertion_point(class_scope:validator.FieldValidator)
    private static final validator.Validator.FieldValidator DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new validator.Validator.FieldValidator();
    }

    public static validator.Validator.FieldValidator getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FieldValidator>
        PARSER = new com.google.protobuf.AbstractParser<FieldValidator>() {
      @java.lang.Override
      public FieldValidator parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FieldValidator> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FieldValidator> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public validator.Validator.FieldValidator getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OneofValidatorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:validator.OneofValidator)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Require that one of the oneof fields is set.
     * </pre>
     *
     * <code>optional bool required = 1;</code>
     * @return Whether the required field is set.
     */
    boolean hasRequired();
    /**
     * <pre>
     * Require that one of the oneof fields is set.
     * </pre>
     *
     * <code>optional bool required = 1;</code>
     * @return The required.
     */
    boolean getRequired();
  }
  /**
   * Protobuf type {@code validator.OneofValidator}
   */
  public static final class OneofValidator extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:validator.OneofValidator)
      OneofValidatorOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 27,
        /* patch= */ 2,
        /* suffix= */ "",
        OneofValidator.class.getName());
    }
    // Use OneofValidator.newBuilder() to construct.
    private OneofValidator(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private OneofValidator() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return validator.Validator.internal_static_validator_OneofValidator_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return validator.Validator.internal_static_validator_OneofValidator_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              validator.Validator.OneofValidator.class, validator.Validator.OneofValidator.Builder.class);
    }

    private int bitField0_;
    public static final int REQUIRED_FIELD_NUMBER = 1;
    private boolean required_ = false;
    /**
     * <pre>
     * Require that one of the oneof fields is set.
     * </pre>
     *
     * <code>optional bool required = 1;</code>
     * @return Whether the required field is set.
     */
    @java.lang.Override
    public boolean hasRequired() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Require that one of the oneof fields is set.
     * </pre>
     *
     * <code>optional bool required = 1;</code>
     * @return The required.
     */
    @java.lang.Override
    public boolean getRequired() {
      return required_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(1, required_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, required_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof validator.Validator.OneofValidator)) {
        return super.equals(obj);
      }
      validator.Validator.OneofValidator other = (validator.Validator.OneofValidator) obj;

      if (hasRequired() != other.hasRequired()) return false;
      if (hasRequired()) {
        if (getRequired()
            != other.getRequired()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRequired()) {
        hash = (37 * hash) + REQUIRED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRequired());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static validator.Validator.OneofValidator parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static validator.Validator.OneofValidator parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static validator.Validator.OneofValidator parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static validator.Validator.OneofValidator parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static validator.Validator.OneofValidator parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static validator.Validator.OneofValidator parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static validator.Validator.OneofValidator parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static validator.Validator.OneofValidator parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static validator.Validator.OneofValidator parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static validator.Validator.OneofValidator parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static validator.Validator.OneofValidator parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static validator.Validator.OneofValidator parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(validator.Validator.OneofValidator prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code validator.OneofValidator}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:validator.OneofValidator)
        validator.Validator.OneofValidatorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return validator.Validator.internal_static_validator_OneofValidator_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return validator.Validator.internal_static_validator_OneofValidator_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                validator.Validator.OneofValidator.class, validator.Validator.OneofValidator.Builder.class);
      }

      // Construct using validator.Validator.OneofValidator.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        required_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return validator.Validator.internal_static_validator_OneofValidator_descriptor;
      }

      @java.lang.Override
      public validator.Validator.OneofValidator getDefaultInstanceForType() {
        return validator.Validator.OneofValidator.getDefaultInstance();
      }

      @java.lang.Override
      public validator.Validator.OneofValidator build() {
        validator.Validator.OneofValidator result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public validator.Validator.OneofValidator buildPartial() {
        validator.Validator.OneofValidator result = new validator.Validator.OneofValidator(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(validator.Validator.OneofValidator result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.required_ = required_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof validator.Validator.OneofValidator) {
          return mergeFrom((validator.Validator.OneofValidator)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(validator.Validator.OneofValidator other) {
        if (other == validator.Validator.OneofValidator.getDefaultInstance()) return this;
        if (other.hasRequired()) {
          setRequired(other.getRequired());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                required_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean required_ ;
      /**
       * <pre>
       * Require that one of the oneof fields is set.
       * </pre>
       *
       * <code>optional bool required = 1;</code>
       * @return Whether the required field is set.
       */
      @java.lang.Override
      public boolean hasRequired() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Require that one of the oneof fields is set.
       * </pre>
       *
       * <code>optional bool required = 1;</code>
       * @return The required.
       */
      @java.lang.Override
      public boolean getRequired() {
        return required_;
      }
      /**
       * <pre>
       * Require that one of the oneof fields is set.
       * </pre>
       *
       * <code>optional bool required = 1;</code>
       * @param value The required to set.
       * @return This builder for chaining.
       */
      public Builder setRequired(boolean value) {

        required_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Require that one of the oneof fields is set.
       * </pre>
       *
       * <code>optional bool required = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRequired() {
        bitField0_ = (bitField0_ & ~0x00000001);
        required_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:validator.OneofValidator)
    }

    // @@protoc_insertion_point(class_scope:validator.OneofValidator)
    private static final validator.Validator.OneofValidator DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new validator.Validator.OneofValidator();
    }

    public static validator.Validator.OneofValidator getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OneofValidator>
        PARSER = new com.google.protobuf.AbstractParser<OneofValidator>() {
      @java.lang.Override
      public OneofValidator parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<OneofValidator> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OneofValidator> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public validator.Validator.OneofValidator getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public static final int FIELD_FIELD_NUMBER = 65020;
  /**
   * <code>extend .google.protobuf.FieldOptions { ... }</code>
   */
  public static final
    com.google.protobuf.GeneratedMessage.GeneratedExtension<
      com.google.protobuf.DescriptorProtos.FieldOptions,
      validator.Validator.FieldValidator> field = com.google.protobuf.GeneratedMessage
          .newFileScopedGeneratedExtension(
        validator.Validator.FieldValidator.class,
        validator.Validator.FieldValidator.getDefaultInstance());
  public static final int ONEOF_FIELD_NUMBER = 65021;
  /**
   * <code>extend .google.protobuf.OneofOptions { ... }</code>
   */
  public static final
    com.google.protobuf.GeneratedMessage.GeneratedExtension<
      com.google.protobuf.DescriptorProtos.OneofOptions,
      validator.Validator.OneofValidator> oneof = com.google.protobuf.GeneratedMessage
          .newFileScopedGeneratedExtension(
        validator.Validator.OneofValidator.class,
        validator.Validator.OneofValidator.getDefaultInstance());
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_validator_FieldValidator_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_validator_FieldValidator_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_validator_OneofValidator_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_validator_OneofValidator_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\017validator.proto\022\tvalidator\032 google/pro" +
      "tobuf/descriptor.proto\"\332\003\n\016FieldValidato" +
      "r\022\r\n\005regex\030\001 \001(\t\022\016\n\006int_gt\030\002 \001(\003\022\016\n\006int_" +
      "lt\030\003 \001(\003\022\022\n\nmsg_exists\030\004 \001(\010\022\020\n\010required" +
      "\030\023 \001(\010\022\023\n\013human_error\030\005 \001(\t\022\020\n\010float_gt\030" +
      "\006 \001(\001\022\020\n\010float_lt\030\007 \001(\001\022\025\n\rfloat_epsilon" +
      "\030\010 \001(\001\022\021\n\tfloat_gte\030\t \001(\001\022\021\n\tfloat_lte\030\n" +
      " \001(\001\022\030\n\020string_not_empty\030\013 \001(\010\022\032\n\022repeat" +
      "ed_count_min\030\014 \001(\003\022\032\n\022repeated_count_max" +
      "\030\r \001(\003\022\021\n\tlength_gt\030\016 \001(\003\022\021\n\tlength_lt\030\017" +
      " \001(\003\022\021\n\tlength_eq\030\020 \001(\003\022\022\n\nis_in_enum\030\021 " +
      "\001(\010\022\020\n\010uuid_ver\030\022 \001(\005\022\030\n\020string_length_g" +
      "t\030\024 \001(\003\022\030\n\020string_length_lt\030\025 \001(\003\022\030\n\020str" +
      "ing_length_eq\030\026 \001(\003\"\"\n\016OneofValidator\022\020\n" +
      "\010required\030\001 \001(\010:I\n\005field\022\035.google.protob" +
      "uf.FieldOptions\030\374\373\003 \001(\0132\031.validator.Fiel" +
      "dValidator:I\n\005oneof\022\035.google.protobuf.On" +
      "eofOptions\030\375\373\003 \001(\0132\031.validator.OneofVali" +
      "datorB2Z0github.com/coderyw/go-proto-val" +
      "idators;validator"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.google.protobuf.DescriptorProtos.getDescriptor(),
        });
    internal_static_validator_FieldValidator_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_validator_FieldValidator_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_validator_FieldValidator_descriptor,
        new java.lang.String[] { "Regex", "IntGt", "IntLt", "MsgExists", "Required", "HumanError", "FloatGt", "FloatLt", "FloatEpsilon", "FloatGte", "FloatLte", "StringNotEmpty", "RepeatedCountMin", "RepeatedCountMax", "LengthGt", "LengthLt", "LengthEq", "IsInEnum", "UuidVer", "StringLengthGt", "StringLengthLt", "StringLengthEq", });
    internal_static_validator_OneofValidator_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_validator_OneofValidator_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_validator_OneofValidator_descriptor,
        new java.lang.String[] { "Required", });
    field.internalInit(descriptor.getExtensions().get(0));
    oneof.internalInit(descriptor.getExtensions().get(1));
    descriptor.resolveAllFeaturesImmutable();
    com.google.protobuf.DescriptorProtos.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
